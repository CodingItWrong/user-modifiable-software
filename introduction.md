---
title: 'Introduction'
---

When thinking about the concept of "power" in software, we often think about computational power: how much computation can be done with given resources. If we abstract this out a bit, power in software is about *getting more done with less*. But computational power isn't the only kind of power like this that exists in software. There is another kind of power: *enabling people to accomplish more with less effort*. You might refer to to this kind of power as "empowerment".

When it comes to empowering people, computing has been through a number of phases:

- Originally, computers were very expensive and only available to professionals in specialized roles. Using them required programming with punch cards, then later terminal interfaces.
- 1972-1980: The Smalltalk programming environment created at Xerox PARC pioneered graphical user interfaces (GUIs) as a way to make computers more accessible to non-technical users, including children.
- 1984: Steve Jobs took inspiration from the GUIs he saw at Xerox PARC and applied them to the Macintosh as a way to make computers "for the rest of us," for non-technical users.
- 1987: HyperCard built on this principle by making not only the use of software but also the *creation* of it something that non-technical people could do.
- 1990: The World Wide Web empowered people by allowing them to receive information from all over the world, as well as (with some effort) sharing their own information.
- 1997: Open-source software empowered users by providing them with their software's source code, so that they can add features or publish their own modified versions of the software to meet their own needs. Open-source libraries and frameworks also saved effort in creating their own software.
- 1999-2006: blogs, Web 2.0, and social media made it easier for people to share information online by making the interfaces to do so available in the browser itself, rather than requiring separate tooling.

But the progress of software empowering people isn't strictly linear. As a few examples of disempowerment:

- Apple's iPhone restricts the programming languages that apps can be written in, and requires apps be distributed through Apple's App Store, which has rigid requirements.
- Centralized social media can't be customized or extended by users: users must use the platforms as provided.

One particular gap in user empowerment today happens when software doesn't perfectly meet the needs of its users. What are a user's options in that case?

For commercial software, you can lobby the manufacturer for the feature you need, but they may not implement it. For open-source software, you can fork the repo and add the feature yourselfâ€”but only if you have software development experience on the platform, and are willing to set up the development environment. Your other option is to rewrite the software yourself in a tech stack you're familiar with.

Are better solutions possible for when software doesn't meet its users' needs? If we look back through the history of computing, there have been several software platforms that allow users to inspect the code of their software and modify it in the same environment the software runs in runs in. It's not a black box like commercial software, and it doesn't require a complicated development environment setup like most open-source software. With these software platforms, if you are using the application, you already have all the tooling you need to see how the application works and modify it.

Platforms like this have played a significant role in the advancement of personal computing. Can such platforms do so again? This site presents two such platforms, Smalltalk and HyperCard. It explores their motivation and development, their properties and impact, and their decline and successors. It assesses these platforms to see the ways they enabled people to modify their software, and whether there are unmet needs that future platforms could address to enable users further.
